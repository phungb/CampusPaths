CSE 331 Homework 5.  Answers to Written questions.
Edit this file to supply your answers.

Name:  Bill Phung

Problem 1. (Written exercises)

(a) IntQueue1 Rep Invariant: no null entries in queue
						        entries != null
			  Abstraction Function: AF(this) = a queue that stores Integers such that
			  								   and that size = number of entries
			  
    IntQueue2 Rep Invariant: no null entries in queue 
    						 size >= 0
    						 0 <= front < number of entries - 1
			  Abstraction Function: AF(this) = a queue that stores Integers such that
			  								   size = number of entries
			  								   front = start of queue
			  
(b) a, d, and g are equivalent [1, 2]
	b, h are equivalent [2, 3, 4]
	c, f, and h are equivalent [1, 2, 3]
	e is equivalent to none [1, 2, 3, 4]


(c)
1. This method takes in primitive types and returns a primitive type leaving no room for mutation 
and representation exposure
2.The return type is a String[] which is mutable thus could lead to representation exposure
3.If Date is mutable and 
4.Does not take in mutable arguments and returns a string with isn't mutable.
5.The iterator can possibly be exposed. Consider a iterator representing a collection and it 
iterating through it after remove has been called.
6.This constructor could expose the representation since it takes in a mutable object. It must
make a copy of this list to act on since the list can be changed from the outside.


Problem 2.  (Graph interface/operations)
addNode and addEdge are necessary to build the graph. containsNode, containsEdge, getLabel, size, getChildren and
isEmpty allows the user to look inside the graph and see useful information. removeEdge is included 
in case the client wants to remove an edge after it is added.

Problem 3.  (Testing strategy)
My testing strategy revolved around using “0, 1, 2” case analysis as described in the hints sections. I used test cases such as
graphs with 0, 1, or 2 nodes or nodes with 0, 1, or 2 edges and tested to see if the graph had the appropriate behavior. I also added tests
to check if exceptions were thrown at given appropriate inputs. Methods calls are often designed to be called after other methods so I tested
the behavior calls to a method after other calls have been made for example testing size after addNode had been called
After that I looked through the specifications I had written and tested for certain promised behaviors such as what to do
when two of the same nodes have been added or what to do when addEdge is called
although an edge between those two nodes had already been established.


Problem 4.  (Representation)
My representation of a graph most resembles a collection of edges. I used a Map that mapped nodes to a map of nodes and labels. The map of nodes
and labels represent the edges associated with that certain node. The benefit of using an collection and my representation is that adding and removing edges can be 
done in O(1) time with the help of HashMap or HashSet. The advantage of a adjacency list representation is that in sparse graphs this representation takes up less space than 
the other ways. The benefit of using a adjacency matrix is that checking if an edge exists or not only takes O(1) time however, these take up more space.

